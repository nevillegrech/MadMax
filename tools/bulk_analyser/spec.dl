// BSD 3-Clause License
//
// Copyright (c) 2016, 2017, The University of Sydney. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.
//
// * Neither the name of the copyright holder nor the names of its
//   contributors may be used to endorse or promote products derived from
//   this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//#include "unstructured_loop_detector.dl"



// NOTE: Relations starting in lowercase are mostly legacy

.type Statement
.type Variable
.type Opcode
.type Value
.type Block
.type Function
      
// INPUT

.decl edge(h:Statement, t:Statement)                // There is a CFG edge from h to t
.input edge
.decl def(var:Variable, stmt:Statement)             // var is defined by stmt
.input def
.decl use(var:Variable, stmt:Statement, i:number)   // var is used by stmt as argument i
.input use
.decl op(stmt:Statement, op:Opcode)                 // stmt's opcode is op
.input op
.decl value(var:Variable, val:Value)                // A variable's possible value set if known
.input value
.decl isBlock(b: Block)
.decl block(s: Statement, b: Block)
.input block

isBlock(b) :- block(_, b).

.decl in_function(b:Block, t:Function)
.input in_function

.decl StatementInPublicFunction(s: Statement, f: Function)

StatementInPublicFunction(s, f) :-
  block(s, b),
  in_function(b, f).

//
// *** INSTRUCTIONS ***
//

// Requires CALL, JUMPI, SSTORE relations.
.decl op_CALL(stmt:Statement, gas:Variable, target:Variable, value:Variable, data_start:Variable, data_length:Variable, return_start:Variable, return_length:Variable)
.input op_CALL
.decl op_JUMPI(stmt:Statement, dest:Variable, condVar:Variable)
.input op_JUMPI
.decl op_SSTORE(stmt:Statement, loc:Variable, val:Variable)
.input op_SSTORE


// Place opcodes into various categories.
.decl unaryArith(opcode:Opcode)
unaryArith("ISZERO").
unaryArith("NOT").

.decl binArith(opcode:Opcode)
binArith("ADD").
binArith("MUL").
binArith("SUB").
binArith("DIV").
binArith("SDIV").
binArith("MOD").
binArith("SMOD").
binArith("EXP").
binArith("SIGNEXTEND").
binArith("LT").
binArith("GT").
binArith("SLT").
binArith("SGT").
binArith("EQ").
binArith("AND").
binArith("OR").
binArith("XOR").
binArith("BYTE").

.decl ternArith(opcode:Opcode)
ternArith("ADDMOD").
ternArith("MULMOD").

.decl runtimeKnowable(opcode:Opcode)
runtimeKnowable("ADDRESS").
runtimeKnowable("ORIGIN").
runtimeKnowable("CALLER").
runtimeKnowable("CALLVALUE").
runtimeKnowable("CALLDATASIZE").
runtimeKnowable("CODESIZE").
runtimeKnowable("GASPRICE").

.decl IsThrow(stmt:Statement)
IsThrow(stmt) :- op(stmt, "THROW").
IsThrow(stmt) :- op(stmt, "THROWI").

// var is the result of a SLOAD operation, stmt
.decl sloadResult(var:Variable, stmt:Statement)
sloadResult(var, stmt) :-
  op(stmt, "SLOAD"),
  def(var, stmt).

.decl FlowOp(op: Opcode)
// Represents operations through which data can "flow"      
FlowOp(op) :- binArith(op).
FlowOp(op) :- unaryArith(op).
FlowOp(op) :- ternArith(op).



// var is the result of a CALL operation, stmt
.decl CallStmt(stmt:Statement)
CallStmt(stmt) :- op(stmt, "CALL").
CallStmt(stmt) :- op(stmt, "CALLCODE").
CallStmt(stmt) :- op(stmt, "DELEGATECALL").
CallStmt(stmt) :- op(stmt, "STATICCALL").


// var is the result of a CALL operation, stmt
.decl CallResult(var:Variable, stmt:Statement)

CallResult(var, stmt) :- CallStmt(stmt), def(var, stmt).

//
// *** CONTROL-FLOW ANALYSIS CONCEPTS *** 
//

.decl Entry(s:Statement)
.decl Exit(s:Statement)
.decl IsStatement(s:Statement)

IsStatement(s) :- op(s, _).

Entry(s) :- IsStatement(s), !edge(_,s).
Exit(s) :- IsStatement(s), !edge(s,_).

.decl IsJump(s:Statement)
IsJump(s) :- op(s, "JUMP").
IsJump(s) :- op(s, "JUMPI").

.decl JumpTarget(s:Statement)
JumpTarget(s) :- op(s, "JUMPDEST").

.decl BasicBlockBegin(s:Statement)
BasicBlockBegin(s) :- Entry(s).
BasicBlockBegin(s) :- JumpTarget(s).
BasicBlockBegin(t) :- IsJump(s), edge(s,t).

.decl NextInSameBasicBlock(s:Statement, next:Statement)
NextInSameBasicBlock(s,next) :-
  edge(s,next), !BasicBlockBegin(next).
NextInSameBasicBlock(s,next) :-
  BasicBlockHead(s,next), edge(s,next).

.decl BasicBlockHead(s:Statement, head:Statement)
BasicBlockHead(s,s) :- BasicBlockBegin(s).
BasicBlockHead(s,h) :- BasicBlockHead(prev,h), NextInSameBasicBlock(prev,s).
 .plan 1:(2,1)

//
// *** Reachability and Dominance ***
//
       
.decl CanReach(s:Statement, t:Statement)

CanReach(s,s) :- IsStatement(s).
CanReach(s,t) :- edge(s,t).
CanReach(s,t) :- CanReach(s,v), edge(v,t).


// defined on basic blocks, identified by their first instruction
.decl SuccessorBB(next:Statement, prev:Statement)
SuccessorBB(next,prev) :-
  BasicBlockHead(exitNode, prev),
  edge(exitNode,next).

.decl PredecessorBB(prev:Statement, next:Statement)
PredecessorBB(prev,next) :-
  SuccessorBB(next,prev).

// Both arguments are basic block heads
// There is a path from the entry to s that does not go through candidate
.decl DoesNotDominate(candidate:Statement, s:Statement)
DoesNotDominate(candidate,s) :-
  Entry(s),
  BasicBlockHead(_, candidate).

DoesNotDominate(candidate,s) :-
  DoesNotDominate(candidate,other),
  SuccessorBB(s,other),
  s != candidate.

// Both arguments are basic block heads
// There is a path from s to the exit that does not go through candidate
.decl DoesNotPostDominate(candidate:Statement, s:Statement)
DoesNotPostDominate(candidate,s) :-
  Exit(exitNode),
  BasicBlockHead(exitNode,s),
  BasicBlockHead(_, candidate).

DoesNotPostDominate(candidate,s) :-
  DoesNotPostDominate(candidate,other),
  SuccessorBB(other,s),
  s != candidate.

// The Dominates/PostDominates relation is defined on basic blocks,
// represented by their first instruction (head). Defining
// a dense quadratic relation, like Dominates, on individual
// instructions would be expensive.
.decl Dominates(dominator:Statement, s:Statement)
Dominates(dominator,s) :-
  BasicBlockHead(_, dominator),
  BasicBlockHead(_, s),
  !DoesNotDominate(dominator,s).

.decl PostDominates(postdominator:Statement, s:Statement)
PostDominates(postdominator,s) :-
  BasicBlockHead(_, postdominator),
  BasicBlockHead(_, s),
  !DoesNotPostDominate(postdominator,s).

//
// *** Data flow and dependency analysis ***
//

// The value of x flows from the value of y
// I.e. y is used to calculate x, for a limited number of operations
// See Also: DependsOn
.decl FlowsFrom(x:Variable, y:Variable)
FlowsFrom(x, x) :- use(x, _, _).
FlowsFrom(x, x) :- def(x, _).
FlowsFrom(x, y) :- def(x, stmt), use(y, stmt, _), op(stmt, op), FlowOp(op).
FlowsFrom(x, z) :- FlowsFrom(x, y), FlowsFrom(y, z).

// The value of x depends on the value of y
// I.e. y is used to calculate x, either directly as an input of the operation
// that defined x, or transitively.
.decl DependsOn(x:Variable, y:Variable)
DependsOn(x, x) :- use(x, _, _).
DependsOn(x, x) :- def(x, _).
DependsOn(x, y) :- def(x, stmt), use(y, stmt, _).
DependsOn(x, z) :- DependsOn(x, y), DependsOn(y, z).

// x controls whether y is executed.
.decl Controls(x:Statement, y:Statement)
Controls(xHead, yHead) :-
  BasicBlockHead(x, xHead),
  edge(x, w1),
  edge(x, w2),
  op(x, "JUMPI"),
  Dominates(w1, yHead),
  !Dominates(w2, yHead).

// useful ?
Controls(xHead, yHead) :-
  op(x, "THROWI"),
  BasicBlockHead(x, xHead),
  Dominates(xHead, yHead).

Controls(x, z) :- Controls(x, y), Controls(y, z). // Transitivity

// var is the guard variable of some conditional jump or throw stmt
.decl ConditionVar(var: Variable, stmt:Statement)
ConditionVar(var, stmt) :- op(stmt, "THROWI"), use(var, stmt, _).
ConditionVar(var, stmt) :- op_JUMPI(stmt, _, var).

// x controls whether y executes by the value in cond
.decl ControlsWith(x:Statement, y:Statement, condVar:Variable)
ControlsWith(xHead, yHead, condVar) :-
  Controls(xHead, yHead),
  BasicBlockHead(x, xHead),
  ConditionVar(condVar, x).



//// ** Recognize structured loops and related stuff **

.decl StructuredLoopBackEdge(from:Statement, to:Statement)
.decl StructuredLoopHead(s:Statement)

StructuredLoopBackEdge(from,to),
StructuredLoopHead(to) :-
  edge(from,to),
  BasicBlockHead(from,h),
  Dominates(to,h).

// Detect a loop body *without* also capturing surrounding loops (i.e., not just SCC)
.decl InStructuredLoop(s:Statement, loophead:Statement)
InStructuredLoop(backEdgeNode,loophead) :- StructuredLoopBackEdge(backEdgeNode,loophead).
InStructuredLoop(loophead,loophead) :- StructuredLoopHead(loophead).
// Can reach back edge node without going through loop head!
InStructuredLoop(s,loophead) :-
  InStructuredLoop(other,loophead),
  edge(s,other),
  other != loophead.

.output InStructuredLoop

.decl ContainsInnerStructuredLoop(loophead:Statement,innerLoopHead:Statement)
ContainsInnerStructuredLoop(loophead,innerLoopHead) :-
  StructuredLoopHead(loophead),
  StructuredLoopHead(innerLoopHead),
  InStructuredLoop(innerLoopHead,loophead),
  innerLoopHead != loophead.
  
.decl InnermostStructuredLoop(loophead:Statement)
InnermostStructuredLoop(loophead) :-
  StructuredLoopHead(loophead),
  !ContainsInnerStructuredLoop(loophead,_).

// condVar determintes whether a loop is exited
.decl LoopExitCond(condVar: Variable, x: Statement)
      
LoopExitCond(condVar, loop) :-
  op_JUMPI(jmpi, _, condVar),
  InStructuredLoop(jmpi, loop),
  edge(jmpi, out),
  !InStructuredLoop(out, loop).

//
//  *** Vulnerability analysis primitives ***
//

.decl CallSuccessControlsException(callStmt:Statement, throwStmt: Statement)
.output CallSuccessControlsException
// The return value of a call (callStmt) controls
// whether an exception is thrown by throwStmt
// Either through a control dependency        
CallSuccessControlsException(callStmt, throwStmt) :-
  CallResult(resVar, callStmt),
  FlowsFrom(condVar, resVar),
  ControlsWith(_, throwStmtHead, condVar),
  BasicBlockHead(throwStmt, throwStmtHead),
  IsThrow(throwStmt).
// Or, directly, through a data dependence of the value thrown
CallSuccessControlsException(callStmt, throwStmt) :-
  CallResult(resVar, callStmt),
  FlowsFrom(condVar, resVar),
  use(condVar, throwStmt, _),
  IsThrow(throwStmt).

/// YS: why FlowsFrom and not DependsOn? Both above and in several places below.


// UNUSED
.decl CallSuccessControlsStore(callStmt:Statement, storeStmt: Statement)
CallSuccessControlsStore(callStmt, storeStmt) :-
  op(storeStmt, "SSTORE"),
  BasicBlockHead(storeStmt, storeStmtHead), 
  ControlsWith(_, storeStmtHead, condVar),
  FlowsFrom(condVar, resVar),
  CallResult(resVar, callStmt).

CallSuccessControlsStore(callStmt, storeStmt) :-
  CallResult(resVar, callStmt),
  FlowsFrom(stateVar, resVar),
  op_SSTORE(storeStmt, _, stateVar).


.decl DynamicBound(x:Statement, dynVar:Variable)
// A loop is dynamically bound by the storage state
// contained in dynVar
.output DynamicBound

// YS: I don't understand if this is correct. Is it common to have data flow into
//  condVar *both* from the induction variable and from the dynamic load? And are
//  both of these necessary?
DynamicBound(loop, dynVar) :-
  InStructuredLoop(sloadStmt, loop),
  sloadResult(dynVar, sloadStmt),
  LoopExitCond(condVar, loop),
  FlowsFrom(condVar, dynVar),
  InductionVariable(v, loop),
  FlowsFrom(condVar, v).

.decl InductionVariable(v:Variable, loop: Statement)
// A variable that is monotonically increasing with each successive iteration in loop
.output InductionVariable
        
// YS: strictly speaking, adding does not guarantee increasing...
InductionVariable(v, loop) :-
  InStructuredLoop(addStmt, loop),
  op(addStmt, "ADD"),
  def(v, addStmt),
  use(v, addStmt, _),
  !VariabledDefinedByNonAddInLoop(v, loop).

.decl VariabledDefinedByNonAddInLoop(v:Variable, loop:Statement)
// A variable that is defined by any statement other than ADD
VariabledDefinedByNonAddInLoop(v, loop) :-
  InStructuredLoop(stmt, loop),
  !op(stmt, "ADD"),
  def(v, stmt).

.decl InductionVariableInitialisedFromStorage(v:Variable, loop: Statement, loadStmt: Statement)
.output InductionVariableInitialisedFromStorage
// An induction variable (v for loop) that is initialised through the result of
// loading something from storage.
        
InductionVariableInitialisedFromStorage(v, loop, loadStmt) :-
  sloadResult(resVar, loadStmt),
  FlowsFrom(v, resVar),
  InductionVariable(v, loop).
      

.decl InductionVariableSavedToStorage(v:Variable, loop: Statement, storeStmt: Statement)
.output InductionVariableSavedToStorage
// An induction variable (v for loop) that is processed and saved to storage

InductionVariableSavedToStorage(v, loop, storeStmt) :-
  InductionVariable(v, loop),
  FlowsFrom(stored, v),
  op_SSTORE(storeStmt, _, stored).


.decl PossiblyResumableLoop(loop: Statement)
.output PossiblyResumableLoop
// A loop that may be able to resumed if the execution is interrupted
// Check whether some induction variable is loaded and stored before/after loop.
PossiblyResumableLoop(loop) :-
  InductionVariableInitialisedFromStorage(v, loop, loadStmt),
  InductionVariableSavedToStorage(v, loop, storeStmt),
  BasicBlockHead(storeStmt, storeStmtHead),
  BasicBlockHead(loadStmt, loadStmtHead),
  // Load has to be able to happen before store
  !Dominates(storeStmtHead, loadStmtHead). 

        
.decl CallAddressFromStorage(loadStmt:Statement, callStmt:Statement)
.output CallAddressFromStorage
// Call an address at callStmt that is loaded at loadStmt from storage      
CallAddressFromStorage(loadStmt, callStmt) :-
  sloadResult(resVar, loadStmt),
  FlowsFrom(target, resVar),
  op_CALL(callStmt, _, target, _, _, _, _, _).

.decl InductiveMassCall(callStmt:Statement, loop:Statement)
.output InductiveMassCall
// Looping through addresses stored in the storage and calling them
// TODO: check whether these are real addresses,
// solidity likes to apply specific masks to addreses.
InductiveMassCall(callStmt, loop) :-
  CallAddressFromStorage(loadStmt, callStmt),
  use(index, loadStmt, _),
  DependsOn(index, var),
  InductionVariable(var, loop).

//
// *** DATA STRUCTURES YAY ***
//

      
.decl KeyToOffset(keyVar:Variable, storeOffsetVar:Variable)
.output KeyToOffset

// keyVar is a variable whose valued is SHA3ed to yield storeOffsetVar
// In the case of an array, only a "fixed" offset is SHA'd
// In the case of a map, a "key" is appended to a "fixed" offset and SHA'd.
// We mostly ignore maps for now as these cannot be iterated
// TODO: use alias analysis to improve soundness/precision
KeyToOffset(keyVar, storeOffsetVar) :-
  op(shaStmt,"SHA3"),
  BasicBlockHead(shaStmt, block),
  BasicBlockHead(storeMemStmt, block),
  op(storeMemStmt,"MSTORE"),
  //use(size, shaStmt, 2),
  use(keyVar, storeMemStmt, 2),
  use(start, shaStmt, 1),
  use(start2, storeMemStmt, 1),
  value(start2, startVal),
  value(start, startVal),
  //value(size, sizeVal),
  def(storeOffsetVar, shaStmt),
  FlowsFrom(storeOffsetVarDerivative, storeOffsetVar),
  use(storeOffsetVarDerivative, storeInst, 1),
  (op(storeInst, "SSTORE") ; op(storeInst, "SLOAD")).

.decl ArrayIdToStorageIndex(c:Value, storeOffsetVar:Variable)
.output ArrayIdToStorageIndex  	 

// the constant value thatâ€™s SHA3ed to yield storeOffsetVar is c
ArrayIdToStorageIndex(const, storeOffsetVar) :-
   KeyToOffset(keyVar, storeOffsetVar),
   def(keyVar, constStmt),
   op(constStmt, "CONST"),
   value(keyVar, const).

.decl MapKeyToStorageIndex(keyVar:Variable, storeOffsetVar:Variable)
.output MapKeyToStorageIndex 	 

MapKeyToStorageIndex(keyVar, storeOffsetVar) :-
   KeyToOffset(keyVar, storeOffsetVar),
   def(keyVar, nonConstStmt),
   !op(nonConstStmt, "CONST").

.decl PossibleArraySizeVariable(resVar:Variable, const:Value, storeOffset:Variable)

// resVar is possibly the size of an array identified by const: when reading directly at address const,
// we get the size of an array. When we want its contents, we need to take the SHA3 of const.
PossibleArraySizeVariable(resVar, const, storeOffset) :-
  sloadResult(resVar, loadStmt),
  use(index, loadStmt, _),
  value(index, const),
  ArrayIdToStorageIndex(const, storeOffset).

.decl IncreasedStorageOnPublicFunction(f: Function, arrayId: Value)
.output IncreasedStorageOnPublicFunction
// When this public function is called, some array symbolized by arrayId is increased in size
        
IncreasedStorageOnPublicFunction(f, arrayId) :-
  PossibleArraySizeVariable(sizeVar, arrayId, _),
  use(sizeVar, addStmt, _),
  op(addStmt, "ADD"),
  StatementInPublicFunction(addStmt, f),
  def(newSizeVar, addStmt),
  op_SSTORE(storeStmt, index, newSizeVar),
  // not sure about the following, what if function calls private function?
  StatementInPublicFunction(storeStmt, f), 
  value(index, arrayId).

.decl PossibleArrayIterator(loop:Statement, resVar:Variable, arrayId:Value)
.output PossibleArrayIterator  	 
// A loop, looping through an array
// Firstly, the loop has to be dynamically bound by some storage var (resVar)
// And this must be the array's size variable.        
PossibleArrayIterator(loop, resVar, arrayId) :-
  DynamicBound(loop, resVar),
  PossibleArraySizeVariable(resVar, arrayId, _).

// 
// ** Specific vulnerabilities **
//

.decl WalletGriefing(x:Statement)
.output WalletGriefing      

        
WalletGriefing(callStmt) :-
  InductiveMassCall(callStmt, loop),        
  InStructuredLoop(callStmt, loop),
  CallSuccessControlsException(callStmt, throwStmt),
  InStructuredLoop(throwStmt, loop),
  !PossiblyResumableLoop(loop).


.decl checkedMassSSTORE(x:Statement)
.output checkedMassSSTORE
checkedMassSSTORE(storeStmt) :-
  IncreasedStorageOnPublicFunction(_, arrayId),
  ArrayIdToStorageIndex(arrayId, storeOffsetVar),
  FlowsFrom(index, i),
  FlowsFrom(index, storeOffsetVar),  
  op_SSTORE(storeStmt, index, _),
  InStructuredLoop(storeStmt, loop),
  InductionVariable(i, loop),
  PossibleArrayIterator(loop, _, arrayId),
  !PossiblyResumableLoop(loop).

